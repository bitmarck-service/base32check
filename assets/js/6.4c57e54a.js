(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{352:function(e,n,t){"use strict";t.r(n);var r=t(43),i=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"einfuhrung"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#einfuhrung"}},[e._v("#")]),e._v(" Einführung")]),e._v(" "),t("h2",{attrs:{id:"base32"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#base32"}},[e._v("#")]),e._v(" Base32")]),e._v(" "),t("p",[e._v("Base32 ist ein Verfahren zur Kodierung von Daten welches im\n"),t("a",{attrs:{href:"https://tools.ietf.org/html/rfc4648#section-6",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 4648, Abschnitt 6"),t("OutboundLink")],1),e._v(" spezifiziert ist.\nEs kodiert eine beliebig lange Folge von Bytes in einen Text der nur aus den Buchstaben "),t("code",[e._v("A")]),e._v(" bis "),t("code",[e._v("Z")]),e._v(" und den Ziffern "),t("code",[e._v("2")]),e._v("\nbis "),t("code",[e._v("7")]),e._v(" besteht.\nDas daraus resultierende Alphabet enthält 32 verschiedene Zeichen - daher der Name.\nZusätzlich wird der Text am Ende solange mit weiteren "),t("code",[e._v("=")]),e._v("-Zeichen ergänzt bis die Textlänge ein Vielfaches von acht ist.")]),e._v(" "),t("p",[e._v("Base32 ist eine gute Wahl für die verbale Übertragung von binären Daten - zum Beispiel am Telefon - weil es keine\nUnterscheidung zwischen Groß- und Kleinbuchstaben gibt und das Alphabet lediglich aus Großbuchstaben und Ziffern\nbesteht, die nicht leichtfertig verwechselt werden können.")]),e._v(" "),t("h2",{attrs:{id:"base32check1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#base32check1"}},[e._v("#")]),e._v(" Base32Check1")]),e._v(" "),t("p",[e._v("Base32Check1 ist ein maßgeschneiderter Algorithmus für eine einstellige Prüfsumme für das Base32-Alphabet, welcher\nursprünglich von "),t("a",{attrs:{href:"https://espadrine.github.io",target:"_blank",rel:"noopener noreferrer"}},[e._v("Thaddée Tyl"),t("OutboundLink")],1),e._v(" entworfen wurde und in einem\n"),t("a",{attrs:{href:"https://espadrine.github.io/blog/posts/a-base32-checksum.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Blog-Posting"),t("OutboundLink")],1),e._v(" vom 29. April 2019 beschrieben ist.\nEr basiert auf einem\n"),t("a",{attrs:{href:"https://www.uni-due.de/imperia/md/content/dc/yanling_2015_check_digit.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("wissenschaftlichen Artikel"),t("OutboundLink")],1),e._v(" von Yanling\nChen, Markku Niemenmaa and A. J. Han Vinck der von Springer am 2. April 2015 online veröffentlich wurde.\nDie Implementierung basiert außerdem auf einigen\n"),t("a",{attrs:{href:"https://johnkerl.org/doc/ffcomp.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("speziellen Optimierungen für Binärzahlen"),t("OutboundLink")],1),e._v(" die von John Kerl im April 2004 online\nveröffentlicht wurden.")]),e._v(" "),t("p",[e._v("Nach Angabe des Artikels by Springer erkennt der Algorithmus zuverlässig die folgenden Fehler, die zusammen über 90% der\nhäufigsten Übertragungsfehler entsprechen, entsprechend statistischer Analysen, die unabhängig von D.F. Beckley and\nJ. Verhoeff durchgeführt wurden:")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Fehler")]),e._v(" "),t("th",[e._v("Beispiel")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("Ersetzung eines einzelnen Zeichens")]),e._v(" "),t("td",[t("code",[e._v("..A..")]),e._v(" → "),t("code",[e._v("..B..")])])]),e._v(" "),t("tr",[t("td",[e._v("Zeichentransposition ohne dazwischenliegende Zeichen")]),e._v(" "),t("td",[t("code",[e._v("..AB..")]),e._v(" → "),t("code",[e._v("..BA..")])])]),e._v(" "),t("tr",[t("td",[e._v("Zeichentransposition mit einem dazwischenliegenden Zeichen")]),e._v(" "),t("td",[t("code",[e._v("..ABC..")]),e._v(" → "),t("code",[e._v("..CBA..")])])]),e._v(" "),t("tr",[t("td",[e._v("Identische Ersetzung von zwei identischen Zeichen ohne dazwischenliegende Zeichen")]),e._v(" "),t("td",[t("code",[e._v("..AA..")]),e._v(" → "),t("code",[e._v("..BB..")])])]),e._v(" "),t("tr",[t("td",[e._v("Identische Ersetzung von zwei identischen Zeichen mit einem dazwischenliegenden Zeichen")]),e._v(" "),t("td",[t("code",[e._v("..ACA..")]),e._v(" → "),t("code",[e._v("..BCB..")])])])])]),e._v(" "),t("details",{staticClass:"custom-block details"},[t("summary",[e._v("Details")]),e._v(" "),t("p",[e._v("Teil des Base32Check1-Algorithmus ist ein wählbares\n"),t("a",{attrs:{href:"http://mathworld.wolfram.com/PrimitivePolynomial.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("primitives Polynom"),t("OutboundLink")],1),e._v(".\nWir haben uns für das Polynom 1 + x + x"),t("sup",[e._v("3")]),e._v(" + x"),t("sup",[e._v("4")]),e._v(" + x"),t("sup",[e._v("5")]),e._v(" entschieden, im Unterschied zu dem\nvon Thaddée Tyl gewählten Polynom 1 + x"),t("sup",[e._v("2")]),e._v(" + x"),t("sup",[e._v("5")]),e._v(".\n"),t("strong",[e._v("Demzufolge unterscheiden sich die Prüfsummen die von unseren Implementierungen berechnet werden von denen, die von der\n"),t("a",{attrs:{href:"https://github.com/espadrine/base32check",target:"_blank",rel:"noopener noreferrer"}},[e._v("originalen Javascript-Implementierung"),t("OutboundLink")],1),e._v(" berechnet werden!")]),e._v("\nAls Indiz dafür daß die zugesicherten Eigenschaften des Algorithmus immer noch eingehalten werden stellen wir daher\nbegleitend zu den Beispielimplementierungen auch Test-Code bereit.")])])])}),[],!1,null,null,null);n.default=i.exports}}]);